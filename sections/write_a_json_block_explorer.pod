=head1 Write a JSON Block Explorer

Z<write_a_json_block_explorer>

If a blockchain is just an append-only database shared by multiple machines
across a network, then any meaning we put onto that chain is a series of models
we apply to raw data. While that could be said of anything computers do, it's
an important point to realize when we want human beings to do meaningful things
with this data.

If that's too abstract for you, consider this: we talk about blocks,
transactions, and addresses not because the blockchain I<requires> that we talk
about these things but because it helps us figure out what's going on and build
things for other humans to use.

X<block explorer>

A piece of software called a I<block explorer> can turn that semi-structured
data from a blockchain into data that machines can more easily understand (even
if they don't understand the blockchain protocols) and that humans can process.
After all, even though a transaction is just a blob of hexadecimal code, it's
easier to figure out when you can see where the inputs came from and where the
outputs go.

Multiple services exist to provide this data via API calls. Some let you use
their data for free. Others cost money. The drawback in all cases is that you
have to trust someone else for this data. Could you tell if they're subtly
wrong? What if they cut you off? What if the service goes away?

Those risks might be worth taking, but you don't have to take them.

=head2 *Write Your Own Block Explorer

What does a block explorer do, anyway? At its core, it reads data about blocks,
transactions, and addresses and presents this in a meaningful way to other
machines or human beings. That's it.

Let's focus on transactions and addresses to demonstrate this possibility.
Other tips (see L<enhance_rpc_calls>) suggest that we can already lay this
foundation by creating, using, or re-using a wrapper around core RPC calls, so
let's think about this for a moment.

One block explorer, C<blockchain.info> had an API pattern where you could get
JSON data for transactions by visiting C<https://blockchain.info/rawtx/...> and
for addresses at C<https://blockchain.info/rawaddr/...>. The former includes
things like the number of confirmations, block height, time, and inputs and
outputs. The latter includes unspent amounts and all transactions with outputs
to the address.

Let's start with transactions.

=head3 *Serving Transaction JSON

X<< Perl libraries; C<Finance::Dogecoin::Utils::NodeRPC> >>

If we use the existing URL pattern, we know what this API has to do; provide a
transaction hash and then produce the results. I'm building on the Perl
C<Finance::Dogecoin::Utils::NodeRPC> code described in another tip, so I'll use
the excellent Perl web framework MojoliciousN<See U<https://mojolicious.org/>
for more details.> in its lightweight version.

The interesting part of the API looks like this:

=begin programlisting

    get '/rawtx/:txhash' => sub ($c) {
        my $txhash = $c->param('txhash');
        my $txdata = $c->node_rpc->call_method( getrawtransaction => $txhash, 1 )->{result};

        $c->render( json => $txdata );
    };

=end programlisting

X<< RPC commands; C<getrawtransaction> >>

If you've never read Mojolicious code before, that's okay. The most important
line is the third line, which calls a method called C<call_method> on a Node
RPC object. This method in turn makes a C<getrawtransaction> RPC call against a
Core node and returns the result. C<getrawtransaction> takes a transaction hash
and an optional parameter to include full data and returns a JSON blob of
transaction information.

X<< configuration options; C<txindex> >>

There's a flaw or weakness in this code, however. If you make this RPC call
against an arbitrary transaction that doesn't affect an address in your wallet,
you'll get an error response saying that this transaction hash isn't in your
mempool. In that case, you need to do one of two things. First, you could
restart your node with the C<txindex> configuration option
(L<index_all_transactions>). Second, we could rewrite this code to expand the
transaction ourselves:

=begin programlisting

    get '/rawtx/:txhash' => sub ($c) {
        my $rpc    = $c->node_rpc;
        my $txhash = $c->param('txhash');
        my $raw_tx = $rpc->call_method( gettransaction => $txhash )->{result};
        my $txdata = $rpc->call_method( decoderawtransaction => $raw_tx->{hex} )->{result};

        $c->render( json => $txdata );
    };

=end programlisting

X<< RPC commands; C<gettransaction> >>
X<< RPC commands; C<decoderawtransaction> >>

The second and third lines have changed; now the code calls C<gettransaction>,
extracts the C<hex> field from the result, and passes that to
C<decoderawtransaction>. While this probably should become its own all-in-one
RPC command, or at least something proxied to it by the Perl library used here,
it serves its purpose in the API and demonstrates a way to go from a
transaction's hash to its full data.

=head3 *Serving Address JSON

X<< RPC commands; C<listreceivedbyaddress> >>

Serving an address is similar, in address information is available through RPC
commands but they don't necessarily make it easy. The C<listreceivedbyaddress>
command returns a list of all addresses the wallet knows about and their
current unspent balances as well as all transactions for which the address was
an output. Unlike transaction data, it's not as easy to get at I<any> arbitrary
address, but it's still instructive to see what it takes to serve only wallet
addresses the Core node knows about.

=begin programlisting

    get '/rawaddr/:address' => sub ($c) {
        my $address = $c->param('address');
        my $rpc     = $c->node_rpc;
        my $addy_data;

        for my $addy ($rpc->call_method('listreceivedbyaddress')->{result}->@*) {
            next unless $addy->{address} eq $address;
            $addy_data = $addy;
            last;
        }

        return $c->render( json => [] ) unless $addy_data;

        $addy_data->{txs} = [];

        for my $txhash ($addy_data->{txids}->@*) {
            my $raw_tx = $rpc->call_method( gettransaction => $txhash )->{result};
            my $tx     = $rpc->call_method( decoderawtransaction => $raw_tx->{hex} );
            push $addy_data->{txs}->@*, $tx->{result};
        }

        delete $addy_data->{txids};

        $c->render( json => $addy_data );
    };

=end programlisting

There's more code here, but it really comes down to two things. Step one, find
the information for the currently requested address in the data returned from
C<listreceivedbyaddress>. Step two, loop through all of the transaction IDs for
that address and get the full transaction information, just as the previous
transaction-handling route did.

Again, this isn't a full general-purpose block explorer because of the address
limitation, but that can be solved with some clever thinkingN<Hint: watch-only
addresses would work.>.

=head3 *The Rest of the Code

Unless you're a Mojolicious developer, you probably need the rest of the code. It looks like this:

=begin programlisting

    use v5.036;

    use Path::Tiny;
    use File::HomeDir;
    use Mojolicious::Lite -signatures;
    use Finance::Dogecoin::Utils::NodeRPC;

    helper conf_dir => sub ($self) {
        state $conf_dir = path(File::HomeDir->my_data)->child('dogeutils')->mkdir;
        return $conf_dir;
    };

    helper auth_file => sub ($self) {
        state $auth_file = $self->conf_dir->child('auth.json');
        return $auth_file;
    };

    helper node_rpc => sub ($self) {
        state $node_rpc = Finance::Dogecoin::Utils::NodeRPC->new(
            user      => $ENV{DOGEUTILS_USER},
            auth_file => $self->auth_file,
        );

        return $node_rpc;
    };

    get '/rawtx/:txhash' => sub ($c) { ... };

    get '/rawaddr/:address' => sub ($c) { ... };

    app->start;

=end programlisting

Most of this is helper code to allow you to use the authorization file set up
in L<enhance_rpc_calls> and to create the RPC object. Pay close attention to
the use of the C<DOGEUTILS_USER> environment variable (see
L<authenticate_rpc_securely>) to provide the name of a user for the RPC
commands.

Run this code with:

=begin screen

  $ B<morbo bin/dogeblockserver>

=end screen

... and you should be able to navigate to U<http://localhost:3000/> and start
making these raw transaction/address calls.

=head2 *Understand the Risks

What's risky here? If you don't go further and figure out how to index all
addresses, anyone who can make JSON HTTP requests against this server can
figure out which addresses belong to the wallet associated with the Core node.

Furthermore, for this to work at all, you have to have a wallet associated with
the Core node, so make sure you protect that wallet to every extent possible.
It may make sense to use only watch-only addresses so you don't have any
private keys accessible from that wallet. It'd still be unpleasant for someone
to get your data, but they can't spend without your private keys, so your
damage is slightly less.

=begin tip I'm Asking Again, Why Perl?

You can do this in any language you like, and it's important to have multiple
implementations in multiple languages, so I chose something that was fast for
me to write, entirely under my control, and not so popular that people would be
intimidated to reimplement it in their own favorite languages. If I assumed
everyone knew and wanted to use Python or Node, you wouldn't be reading this
tip and thinking "Hm, maybe I should rewrite this in something I like better."

=end tip

=head2 *What Can You Do With This?

Now that you have a way to get address and transaction data out of a Core node
into a machine-readable format I<and> you can do so over any network that
supports HTTP, you can build all sorts of applications and tools. You can go
further and add block navigation and exploration support. You could put a nice
HTML/JavaScript interface on this data and make calls back into the system to
click through blocks, transactions, and addresses.

You could visualize the entire blockchain in 3D or other graphical formats.

Of course, you can also make the server more robust. Perhaps it should support
HTTPS, so putting the application behind a reverse proxy to terminate TLS
connections can make it more secure. Maybe it could support some sort of token
or authentication system to limit the types of queries specific users could
ask.

Because transaction and block information is fixed and immutable, you could
even cache query results to avoid unnecessary round trips between the server
and the Core node. Caching address information is trickier, because every new
block processed could consume an address's input or add an output to an
address, but you could set cache headers of 60 seconds and provide good
responsiveness.

None of this code is so complex you couldn't port it to another language;
deploying an all-in-one binary with Golang or Rust could make a trivial but
useful addition to a node you run in the cloud or on a network you control
somewhere. The important thing is that this data is entirely under your
control, with no access limits, API permissions, or waiting to add or change
features.
